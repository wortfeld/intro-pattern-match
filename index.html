<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ffmpeg.wasm PoC – GitHub Pages</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 24px; }
    h1 { font-size: 18px; margin: 0 0 8px; }
    .note { font-size: 13px; color: #333; margin-bottom: 16px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 12px; }
    button { padding: 8px 12px; border: 1px solid #ccc; border-radius: 8px; background: #f7f7f7; cursor: pointer; }
    button:disabled { opacity: .6; cursor: default; }
    #log { white-space: pre-wrap; font-family: Consolas, Menlo, monospace; border: 1px solid #ddd; background: #fafafa; padding: 10px; border-radius: 8px; min-height: 140px; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #eee; font-size: 12px; margin-left: 8px; }
  </style>
</head>
<body>
  <h1>ffmpeg.wasm PoC – GitHub Pages</h1>
  <div class="note">
    Needs these files in the Pages artifact (your workflow adds them):
    <ul>
      <li><code>vendor/ffmpeg/umd/ffmpeg.js</code> (+ its chunk file)</li>
      <li><code>vendor/ffmpeg/core/umd/ffmpeg-core.js</code> and <code>ffmpeg-core.wasm</code></li>
      <li><code>.nojekyll</code> in the root</li>
    </ul>
  </div>

  <div class="row">
    <button id="btnLoad">1) Load ffmpeg</button>
    <button id="btnVersion" disabled>2) Run -version</button>
    <span id="status" class="pill">not loaded</span>
  </div>

  <div class="row">
    <input id="fileInput" type="file" accept="video/*,audio/*" disabled>
    <button id="btnExtract" disabled>3) Extract 2s WAV</button>
    <a id="downloadLink" style="display:none">download result</a>
  </div>

  <div id="log"></div>

  <!-- Load UMD bundle from your repo (the chunk sits in the same folder). -->
  <script src="./vendor/ffmpeg/umd/ffmpeg.js"></script>
  <script>
  (function(){
    var logEl = document.getElementById('log');
    function log(s){
      var t = document.createTextNode(s);
      logEl.appendChild(t);
      logEl.appendChild(document.createElement('br'));
      logEl.scrollTop = logEl.scrollHeight;
    }

    var btnLoad = document.getElementById('btnLoad');
    var btnVersion = document.getElementById('btnVersion');
    var btnExtract = document.getElementById('btnExtract');
    var fileInput = document.getElementById('fileInput');
    var downloadLink = document.getElementById('downloadLink');
    var statusEl = document.getElementById('status');

    var ffmpeg = null;

    window.addEventListener('error', function(e){ log('window error: ' + e.message); });
    window.addEventListener('unhandledrejection', function(e){
      var r = e && e.reason ? (e.reason.message || e.reason) : 'unknown';
      log('unhandled rejection: ' + r);
    });

    // small helper: fetch -> blob: URL (avoids import/MIME/CORS edge cases)
    function toBlobURL(url, mime){
      return fetch(url).then(function(r){
        if(!r.ok) throw new Error('fetch ' + r.status + ' ' + url);
        return r.arrayBuffer();
      }).then(function(buf){
        return URL.createObjectURL(new Blob([buf], { type: mime }));
      });
    }

    log('typeof FFmpegWASM = ' + (typeof window.FFmpegWASM));

    btnLoad.addEventListener('click', function(){
      if (!window.FFmpegWASM) {
        log('FFmpegWASM global missing. Check ./vendor/ffmpeg/umd/ffmpeg.js and its chunk.');
        return;
      }
      var FFmpegClass = window.FFmpegWASM.FFmpeg;
      ffmpeg = new FFmpegClass();
      ffmpeg.on('log', function(ev){ if (ev && ev.message) log('[ffmpeg] ' + ev.message); });

      statusEl.textContent = 'loading';

      // Core bases (UMD): local -> jsDelivr -> unpkg
      var bases = [
        new URL('./vendor/ffmpeg/core/umd/', document.baseURI).href,
        'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/umd/',
        'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/'
      ];

      function tryBase(i){
        if(i>=bases.length) return Promise.reject(new Error('no core base worked'));
        var base = bases[i];
        log('trying core base: ' + base);
        return Promise.all([
          toBlobURL(base + 'ffmpeg-core.js', 'text/javascript'),
          toBlobURL(base + 'ffmpeg-core.wasm', 'application/wasm')
        ]).then(function(arr){
          return { coreURL: arr[0], wasmURL: arr[1] };
        }).catch(function(e){
          log('base failed: ' + e);
          return tryBase(i+1);
        });
      }

      tryBase(0).then(function(u){
        log('ffmpeg.load with resolved blob URLs');
        return ffmpeg.load(u);
      }).then(function(){
        log('ffmpeg loaded');
        statusEl.textContent = 'loaded';
        btnVersion.disabled = false;
        btnExtract.disabled = false;
        fileInput.disabled = false;
      }).catch(function(err){
        statusEl.textContent = 'load error';
        log('ffmpeg.load error: ' + err);
      });
    });

    btnVersion.addEventListener('click', function(){
      if (!ffmpeg) { log('ffmpeg not loaded'); return; }
      log('running: ffmpeg -version ...');
      ffmpeg.exec(['-version']).then(function(res){
        log('done (returnCode=' + (res && res.returnCode) + ')');
      }).catch(function(err){ log('run error: ' + err); });
    });

    btnExtract.addEventListener('click', function(){
      if (!ffmpeg) { log('ffmpeg not loaded'); return; }
      var file = fileInput.files && fileInput.files[0];
      if (!file) { log('pick a file first'); return; }
      downloadLink.style.display = 'none';
      downloadLink.removeAttribute('href');
      downloadLink.removeAttribute('download');

      file.arrayBuffer().then(function(buf){
        return ffmpeg.writeFile('in.bin', new Uint8Array(buf));
      }).then(function(){
        log('executing: -t 2 -i in.bin -vn -ac 1 -ar 16000 -sample_fmt s16 out.wav');
        return ffmpeg.exec(['-t','2','-i','in.bin','-vn','-ac','1','-ar','16000','-sample_fmt','s16','out.wav']);
      }).then(function(){
        return ffmpeg.readFile('out.wav');
      }).then(function(data){
        var blob = new Blob([data], { type: 'audio/wav' });
        var url = URL.createObjectURL(blob);
        downloadLink.href = url;
        downloadLink.download = 'snippet.wav';
        downloadLink.textContent = 'download result (snippet.wav)';
        downloadLink.style.display = 'inline-block';
        log('ready: you can download snippet.wav');
      }).catch(function(err){
        log('extract error: ' + err);
      }).finally(function(){
        try { ffmpeg.deleteFile('in.bin'); } catch(_){}
        try { ffmpeg.deleteFile('out.wav'); } catch(_){}
      });
    });
  })();
  </script>
</body>
</html>
